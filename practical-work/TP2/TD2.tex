	\documentclass[a4paper, 11pt, french]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{epsfig}  
\usepackage{setspace}

\voffset -0cm
\hoffset 0.0cm
\textheight 22cm
\textwidth 16cm
\topmargin 0.0cm
\oddsidemargin 0.0cm
\evensidemargin 0.0cm


\title{\bf{TP2 \\ Manipulations d'histogramme}}
\author{}
\date{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Debut du document %%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle

% Intro

\section*{\bf Analyse et transformation d'histogrammes}

\subsection*{\bf Exercice 1. \rm Analyse et export d'histogramme}

\par On va s'intéresser à l'amélioration des images \texttt{objects-dark.pgm} et \texttt{len\_dark.pgm}

\begin{enumerate}
	\item Reprenez le code du TP1 pour le chargement d'une image PGM
	\item Construisez un petit programme qui charge une image et construit l'histogramme normalisé de cette dernière (vous exportez cet histogramme dans un fichier texte tabulé (1ere colonne = intensité, 2ième colonne = nombre de pixels ayant cette intensité / nombre total de pixels)
	\item Générer les trcés des histogrammes via gnuplot (cf annexe). Qu'observez-vous sur l'histogramme des images PGM précédentes ? 
\end{enumerate}

\subsection*{\bf Exercice 2. \rm Transformation}

Dans ce qui suit, nous considérons que l'histogramme est normalisé sur les intensités. Ainsi, les intensités de l'histogramme de intervalle $[0,M]$ sont normalisées dans $[0,1]$.

\begin{enumerate}
	\item Implémentez les transformations d'histogramme suivantes 
	\begin{itemize}
		\item Inversion d'histogramme
		\item Gamma-correction :  $i' = i^\frac{1}{\gamma}$. Vérifier son comportement sur $\gamma=2.2$, $\gamma=\frac{1}{2.2}$ 
		\item Interpolation linéaire $[a,b]\subset[0,1]\rightarrow [0,1]$
	\end{itemize}
À chaque fois, vous illustrez la transformation par:
\begin{itemize}
	\item un tracé gnuplot de la fonction $\phi$ de transformation d'histogramme
	\item deux tracés avant/après sur les histogrammes
	\item l'image PGM modifiée
\end{itemize}
\end{enumerate}


\subsection*{\bf Exercice 3. \rm Egalisation}

Comme décrit dans le cours, l'objectif est de construire une fonction de transfert $\phi$ entre l'histogramme de l'image, vue comme une distribution empirique de probabilité $p(i)$, vers une distribution cible. Dans le cas présent, nous cherchons à maximiser l'entropie de l'image en ciblant une distribution uniforme. 

Etant donné un histograme sur des intensités dans l'intervalle $[0,M]$, nous cherchons donc à cibler une distribution telle que la probabilité de chaque niveau de gris $i'=\phi(i)$ d'apparaitre dans l'image est $p'(i')=\frac{1}{M}$.

Dans le cas de variables et distributions continues et pour une transformation $\phi$ croissante, nous avons :
\begin{equation}
  p'(\phi(i)) = p(i)\frac{di}{di'}
\end{equation}
Ainsi, 
\begin{equation}
  di' = Mp(i) di
\end{equation}
Et donc,
\begin{equation}
  \phi(i) =  M \int_0^i p(\omega)d\omega
\end{equation}

Dans le cas discret, la transformation $\phi$ s'écrit:
\begin{equation}
  \phi(i) = M\frac{\sum_{j=0}^{i} hist(j)}{\sum_{j=0}^M hist(j)}
\end{equation}

{\bf Implémentez l'égalisation d'histogramme décrite précédemment et testez cette transformation sur quelques images (avec tracés gnuplot de $\phi$ et des histogrammes avant/après)}


% -------------------------------------------------------------------------
\section*{\bf Segmentation d'images par histogramme}

\subsection*{\bf Exercice 1. \rm Seuillage naif}

\begin{itemize}
	\item Construisez un petit programme qui charge une image, calcule son histogramme et seuil l'image initiale selon une certaine intensité.
\end{itemize}



\subsection*{\bf Exercice 2. \rm Minimisation de variance}

On va s'intéresser différentes techniques pour automatiser la recherche d'un \emph{bon} seuil.

L'objectif de la methode de Fisher est de minimiser la variance intra-classe des deux classes (objet / fond).  Plus formellement, nous considérons un histogramme normalisé $H$ d'intensités $[0,M]$ et un seuil $t$ définissant deux classes (\emph{B=background, O=object}) de valeurs dans l'histogramme. Nous cherchons à minimiser la fonctionnelle
\begin{equation}
  \sigma^2_{intra}(t) = n_B(t)\sigma^2_B(t) + n_O(t)\sigma^2_O(t)
\end{equation}
avec
\begin{align}
  n_B(t)  &= \sum_{i=0}^{t-1} H(i)\\
  n_O(t)  &= \sum_{i=t}^{M} H(i)\\
\mu_B(t) &= \frac{1}{n_B(t)} \sum_{i=0}^{t-1} H(i)\\
\mu_O(t) &= \frac{1}{n_O(t)} \sum_{i=t}^{M} H(i)\\
\sigma^2_B(t) &= \frac{1}{n_B(t)} \sum_{i=0}^{t-1}(j-\mu_B(t))^2 H(i)\\
\sigma^2_O(t) &= \frac{1}{n_O(t)} \sum_{i=t}^{M}(j-\mu_o(t))^2 H(i)
\end{align}


{\bf Question 1} Écrivez le bout de code qui permet de calculer $\sigma^2_{intra}(t)$. Pour une image donnée, calculez le $argmin_{t\in{0..M}}(\sigma^2_{intra}(t))$ et effectuez le seuillage avec ce seuil.

Otsu a observé que minimiser la variance intra-classe est équivalente à maximiser la variance entre les classes définies (après réécriture) par :
\begin{equation}
   \sigma^2_{entre}(t) = n_B(t)n_O(t)\left(\mu_B(t) - \mu_O(t) \right ) ^2
\end{equation}

{\bf Question 2} Ecrivez le code correspondant à la maximisation de $\sigma^2_{entre}(t)$. En pratique, ça ne doit pas changer le seuil optimal trouvé mais vous donner un algorithme plus efficace. Afin d'être efficace, n'oubliez pas de mettre à jour incrémentalement les quantités $n_i$ et $\mu_i$. Par exemple
\begin{align}
  n_B(t+1) & = n_B(t) + H(t+1)\\
  \mu_B(t+1)& = ....
\end{align}


\newpage
\section*{\bf Annexe \rm Crash-course Gnuplot}

Given a text file with tabular data (several columns, separated by spaces or tabs..) \texttt{toto.txt}
\begin{itemize}
\item Display a graph where abscissa/ordinate  are mapped to first/third column  
\begin{verbatim}
  plot "toto.txt" using 1:3 with points
\end{verbatim}

\item Same graph with lines and points between datum
\begin{verbatim}
  plot "toto.txt" using 1:3 with linespoints
\end{verbatim}
\item Y-axis is the sum of the second and third column and we limimt
  the x-axis range to $[0,10]$
\begin{verbatim}
  plot [0:10] "toto.txt" using 1:($3+$2) with linespoints
\end{verbatim}
\item Labels
\begin{verbatim}
  set xlabel "Abscissa"
  set ylabel "Abscissa"
\end{verbatim}
\item The next ``plot'' command will output the graph in a PDF file
  (with enhanced and color properties)
\begin{verbatim}
  set terminal pdf enhanced color
  set output "glop.pdf"
\end{verbatim}
\item To use the X11 terminal (default one)
\begin{verbatim}
  set terminal X11
  unset output
\end{verbatim}
\item Need some help on the plot command
\begin{verbatim}
  help plot
\end{verbatim}

\end{itemize}


\end{document}

